<!DOCTYPE html>  
<html lang="en">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <title>Canvas Mind Map</title>  
    <style>  
        canvas {  
            border: 1px solid black;  
        }  
    </style>  
</head>  
<body>  
    <canvas id="mindMapCanvas" width="800" height="1000"></canvas>  
    <script>

window.onload = function() {  
    // 获取canvas元素
    const canvas = document.getElementById('mindMapCanvas');  
    // 获取canvas的绘图上下文
    const ctx = canvas.getContext('2d');  
  
    // 获取canvas的中心点坐标
    const centerX = canvas.width / 2;  
    const centerY = canvas.height / 2;  
    // 设置节点之间的距离
    const distance = 200;  
  
    // 中心节点绘制函数
    function drawNode(x, y, text) {  
        // 开始绘制路径
        ctx.beginPath();  
        // 绘制外部圆形
        ctx.arc(x, y, 50, 0, Math.PI * 2, true); 
        // 设置填充颜色
        ctx.fillStyle = 'white';  
        // 填充圆形
        ctx.fill();  
        // 设置边框宽度
        ctx.lineWidth = 2;  
        // 设置边框颜色
        ctx.strokeStyle = '#003300';  
        // 绘制边框
        ctx.stroke();  
  
        // 设置文本填充颜色为黑色
        ctx.fillStyle = '#000000';  
        // 设置字体为Arial，大小为14px
        ctx.font = '14px Arial';  
        // 设置文本居中对齐
        ctx.textAlign = 'center';  
        // 在指定位置绘制文本
        ctx.fillText(text, x, y + 5);  
    }  

    // 子节点绘制函数
    function drawchildNode(x, y, text) {  
        // 开始绘制路径
        ctx.beginPath();  
        // 绘制外部圆形
        ctx.arc(x, y, 50, 0, Math.PI * 2, true); 
        // 设置填充颜色
        ctx.fillStyle = 'white';  
        // 填充圆形
        ctx.fill();  
        // 设置边框宽度
        ctx.lineWidth = 2;  
        // 设置边框颜色
        ctx.strokeStyle = '#003300';  
        // 绘制边框
        ctx.stroke();  
  
        // 设置文本填充颜色为黑色
        ctx.fillStyle = '#000000';  
        // 设置字体为Arial，大小为14px
        ctx.font = '14px Arial';  
        // 设置文本居中对齐
        ctx.textAlign = 'center';  
        // 在指定位置绘制文本
        ctx.fillText(text, x, y + 5);  
    }  

    // 连线绘制函数：绘制一条(x1, y1) 到 (x2, y2) 的连线
    function drawLine(x1, y1, x2, y2) {  
        // 开始绘制路径
        ctx.beginPath();  
        // 移动到起点
        ctx.moveTo(x1, y1);  
        // 绘制直线到终点
        ctx.lineTo(x2, y2);  
        // 设置线条宽度
        ctx.lineWidth = 2;  
        // 设置线条颜色
        ctx.strokeStyle = '#003300';  
        // 绘制路径
        ctx.stroke();  
    }     

    // 示例分支
    const branches = [  
        { text: 'Branch 1', 
          angle: 0, 
          distance: distance, 
          children: []
        },  
        { text: 'Branch 2',
          angle: Math.PI / 2,
          distance: distance, 
          children: [
            { text: 'Branch 2.1.1', angle: Math.PI / 2, distance: distance, children: [] },
            { text: 'Branch 2.1.2', angle: Math.PI*3 / 4, distance: distance, children: []},
            { text: 'Branch 2.1.3', angle: Math.PI / 2, distance: distance, children: [] },
            { text: 'Branch 2.1.4', angle: Math.PI / 4, distance: distance, children: [] }] 
        },
        { text: 'Branch 3', angle: Math.PI, distance: distance, children: [] },  
        { text: 'Branch 4', angle: -Math.PI / 2, distance: distance, children: [] } 
    ];  

    // 节点递归生成函数，输入参数为父节点的坐标和文本
    function GenerateNodes(ParentNodeX, ParentNodeY, Parenttext, branches) {
        // 若父节点的分支branches非空，则进入
        if(branches.length > 0){
            branches.forEach(branch => {
                // 计算当前子节点NextNode的坐标X
                const NextNodeX = ParentNodeX + distance * Math.cos(branch.angle);  
                // 计算当前子节点NextNode的坐标Y
                const NextNodeY = ParentNodeY + distance * Math.sin(branch.angle); 
                // 如果当前子节点NextNode的的分支branch.children非空，则进入
                if(branch.children.length > 0){
                    GenerateNodes(NextNodeX, NextNodeY, branch.text, branch.children); 
                }
                // 绘制当前子节点与父节点之间的连线 
                drawLine(NextNodeX, NextNodeY, ParentNodeX, ParentNodeY);  
                // 绘制当前子节点
                drawchildNode(NextNodeX, NextNodeY, branch.text);  
            })
        }
        // 子节点绘制完成后再绘制中心节点
        drawNode(ParentNodeX, ParentNodeY, Parenttext);  

    }    

    // 生成节点
    GenerateNodes(centerX, centerY, '中心', branches);


};

    </script>  
</body>  
</html>